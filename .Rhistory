colors <- c("setosa" = "red", "versicolor" = "green3", "virginica" = "blue")
plot(iris[, 3:4], pch = 21, bg = colors[iris$Species], col = colors[iris$Species])
euclideanDistance <- function(u, v) {
sqrt(sum((u - v)^2))
}
sort <- function(xl, point, euclideanDistance)
{
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
}
PentalWedth <- seq(from = min(iris[ , 3]), to = max(iris[ , 3]), by = 0.1) #РІСЃРµ СЃС‚СЂРѕРєРё РІ СЃС‚РѕР»Р±С†Рµ
PentalLength <- seq(from = min(iris[ , 4]), to = max(iris[ , 4]), by = 0.1)
for (i in PentalWedth)
for (j in PentalLength)
point <- c(i,j)
distances <- matrix(NA, l, 2)
for (k in 1:l)
{
distances[k, ] <- c(k, euclideanDistance(xl[k, 1:n], point))
}
orderedxl <- xl[order(euclideanDistance[ , 2], )] #СЃРѕСЂС‚РёСЂРѕРІРєР° СЂР°СЃСЃС‚РѕСЏРЅРёСЏ
classes <- orderedxl[1:k, n+1] #РёРјРµРЅР° РїРµСЂРІС‹С… k РєР»Р°СЃСЃРѕРІ РёР· orderedxl
count <- table(classes)  #table-РІРѕР·РІСЂР°С‰Р°РµС‚ С‚Р°Р±Р»РёС†Сѓ СЃ С‡aСЃС‚РѕС‚Р°РјРё РІСЃС‚СЂРµС‡Р°РµРјРѕСЃС‚Рё РєР°Р¶РґРѕРіРѕ Р·РЅР°С‡РµРЅРёСЏ classes
colors <- c("setosa" = "red", "versicolor" = "green3", "virginica" = "blue")
plot(iris[, 3:4], pch = 21, bg = colors[iris$Species], col = colors[iris$Species])
euclideanDistance <- function(u, v) {
sqrt(sum((u - v)^2))
}
xl <- iris[, 3:5]
l <- dim(xl)[1] # 150
n <- dim(xl)[2] - 1 # 2
X <- seq(from = min(iris[, 3]), to = max(iris[, 3]), by = 0.1) # Petal.Length
Y <- seq(from = min(iris[, 4]), to = max(iris[, 4]), by = 0.1) # Petal.Width
distances <- matrix(NA, l, n) # матрица расстояний
for(i in X) {
for(j in Y) {
point <- c(i, j)
for(k in 1:l){
distances[k, ] <- c(k, euclideanDistance(xl[k, 1:n], point))
}
orderedxl <- xl[order(distances[ , 2]), ] # сортировка расстояний
points(point[1], point[2], pch = 21, bg = "white", col = colors[orderedxl$Species[1]])
}
}
colors <- c("setosa" = "red", "versicolor" = "green3", "virginica" = "blue")
plot(iris[, 3:4], pch = 21, bg = colors[iris$Species], col = colors[iris$Species])
euclideanDistance <- function(u, v) {
sqrt(sum((u - v)^2))
}
xl <- iris[, 3:5]
l <- dim(xl)[1] # 150
n <- dim(xl)[2] - 1 # 2
X <- seq(from = min(iris[, 3]), to = max(iris[, 3]), by = 0.1) # Petal.Length
Y <- seq(from = min(iris[, 4]), to = max(iris[, 4]), by = 0.1) # Petal.Width
distances <- matrix(NA, l, n) # матрица расстояний
for(i in X) {
for(j in Y) {
point <- c(i, j)
for(k in 1:l){
distances[k, ] <- c(k, euclideanDistance(xl[k, 1:n], point))
}
orderedxl <- xl[order(distances[ , 2]), ] # сортировка расстояний
points(point[1], point[2], pch = 21, bg = "white", col = colors[orderedxl$Species[1]])
}
}
v <- iris[, 3:4]
p <- c(3, 1)
avg <- function(x)
{
sum(x) / length(x)
}
colors <-
c("setosa" = "red",
"versicolor" = "green",
"virginica" = "blue")
ax <- avg(iris[iris$Species == "setosa", 3])
ay <- avg(iris[iris$Species == "setosa", 4])
bx <- avg(iris[iris$Species == "versicolor", 3])
by <- avg(iris[iris$Species == "versicolor", 4])
cx <- avg(iris[iris$Species == "virginica", 3])
cy <- avg(iris[iris$Species == "virginica", 4])
plot(iris[, 3:4],
pch = 21,
bg = colors[iris$Species],
col = colors[iris$Species])
points(ax, ay, pch = 20, col = "black")
points(bx, by, pch = 20, col = "black")
points(cx, cy, pch = 20, col = "black")
points(p, pch = 20, col = "yellow", lwd = 9)
dist <- function(u, v)
{
sqrt(sum((u - v) ^ 2))
}
a <- dist(c(ax, ay), p)
b <- dist(c(bx, by), p)
c <- dist(c(cx, cy), p)
min(c(a, b, c))
euclideanDistance <- function(u, v) {
sqrt(sum((u - v) ^ 2))
}
sortObjectsByDist <- function(xl, z, metricFunction = euclideanDistance)
{
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l) {
distances[i,] <- c(i, metricFunction(xl[i, 1:n], z))
}
orderedXl <- xl[order(distances[, 2]),]
return (orderedXl<-cbind( orderedXl, evcld = sort(distances[,2],decreasing =FALSE)))
}
kNN <- function(xl, z, k) {
orderedXl <- sortObjectsByDist(xl, z, euclideanDistance)
n <- dim(orderedXl)[2] - 1
classes <-orderedXl[1:k, n + 1]
counts <- table(classes)
class <- names(which.max(counts))
return (class)
}
plot(
iris[, 3:4],
pch = 21,
bg = colors[iris$Species],
col = colors[iris$Species],
asp = 1
)
class <-kNN(xl, z, k = 6)
points(z[1], z[2], pch = 22, bg = colors[class], col = colors[class], asp = 1, lwd = 5)
##########################   OKNA #####################################
#ïðÿìîóãîëüíîå
u_func <- function(rast, h) {
if(abs(rast/h) <= 1){
return (0.5)
} else {
return(0)
}
}
#åïà÷íèêîâà
func_epanechnikov <-function(rast, h){
if(abs(rast/h) <= 1){
return(3/4 * (1 - (rast/h)^2))
} else {
return(0)
}
}
#êâàäðàòè÷íîå
func_kvadrat <-function(rast, h){
if(abs(rast/h) <= 1){
return(15/16 * (1 - (rast/h)^2)^2)
} else {
return(0)
}
}
#òðåóãîëüíîå
func_treyg <-function(rast, h){
if(abs(rast/h) <= 1){
return(1-abs(rast/h))
} else {
return(0)
}
}
#ãàóñîâñêîå
funk_gaus <- function(rast, h){
if(abs(rast/h) <= 1){
return ( (2*pi)^(-1/2) * exp(-1/2 * (rast/h)^2 ) )
} else {
return(0)
}
}
#LOO äëÿ îêíà, ïðèíèìàåò êëàññèôèêàòîð è ôóíêöèþ ÿäðà
LOO <- function(classificator, fanc){
vec <- c(seq(1, 45))
tmp <- 1
for (h in seq(0.5,5,by=0.1)) {
cnt <- 0
for (i in 1:150) {
x_el <- c(iris[i, 3], iris[i, 4])
x_sample <- iris[-i, 3:5]
class <- classificator(x_sample, x_el, h, fanc)
#print(class)
# print(iris[i, 5])
#print(x_el)
#print(x_sample)
if (iris[i, 5] != class) {
cnt <- cnt + 1
}
}
#print(cnt)
vec[tmp] <- cnt / 150
print(tmp)
tmp = tmp + 1
}
return (vec)
}
#ordinary parzen classificator
parzen_window <- function(xl, z, h, fanc) {
orderedXl <- sortObjectsByDist(xl, z, euclideanDistance)
n <- dim(orderedXl)[2]-1
classes <-orderedXl[1:150, n]
m = c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
for (i in seq(1:149)){
#print(m)
m[[classes[i]]] <- m[[classes[i]]] + fanc(orderedXl[i,4], h)
}
class <- names(which.max(m))
return (class)
}
#parzen window with different step
parzen_window_perem_shag <- function(xl, z, h, u_func) {
orderedXl <- sortObjectsByDist(xl, z, euclideanDistance)
n <- dim(orderedXl)[2]-1
classes <-orderedXl[1:150, n]
m = c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
for (i in seq(1:149)){
#print(m)
m[[classes[i]]] <- m[[classes[i]]] + u_func(orderedXl[i,4], h)
}
class <- names(which.max(m))
return (class)
}
z <-c(2.7, 1)
xl <-iris[, 3:5]
#LOO results for ordinary parzen window
LOO_pramoygolnik  = LOO(parzen_window, u_func)
avg <- function(x)
{
sum(x) / length(x)
}
colors <-
c("setosa" = "red",
"versicolor" = "green",
"virginica" = "blue")
plot(iris[, 3:4],
pch = 21,
bg = colors[iris$Species],
col = colors[iris$Species])
euclideanDistance <- function(u, v) {
sqrt(sum((u - v) ^ 2))
}
sortObjectsByDist <- function(xl, z, metricFunction = euclideanDistance)
{
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l) {
distances[i,] <- c(i, metricFunction(xl[i, 1:n], z))
}
orderedXl <- xl[order(distances[, 2]),]
return (orderedXl)
}
kNN <- function(xl, z, k) {
orderedXl <- sortObjectsByDist(xl, z, euclideanDistance)
n <- dim(orderedXl)[2] - 1
classes <-orderedXl[1:k, n + 1]
counts <- table(classes)
class <- names(which.max(counts))
return (class)
}
#z <-c(2.7, 1)
#xl <-iris[, 3:5]
#class <-kNN(xl, z, k = 6)
#points(z[1], z[2], pch = 22, bg = colors[class], col = colors[class], asp = 1, lwd = 5)
kNN <- function(){
vec = c(seq(1, 150))
for (k in 1:150) {
cnt <- 0
for (i in 1:150) {
x_el <- c(iris[i, 3], iris[i, 4])
x_sample <- iris[-i, 3:5]
class <- kNN(x_sample, x_el, k)
if (iris[i, 5] != class) {
cnt = cnt + 1
}
}
vec[k] <- cnt / 150
print(vec[k])
}
}
plot(
seq(1, 150), vec,
type="p", col="red", bg= "red", pch = 21, ylab = "Error", xlab = "k", main = "LOO for kN"
)
colors <-
c("setosa" = "red",
"versicolor" = "green",
"virginica" = "blue")
